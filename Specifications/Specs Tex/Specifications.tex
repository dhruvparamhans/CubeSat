\documentclass[11pt,a4paper]{report}

\usepackage[margin=1.0in]{geometry}
\usepackage{polytechnique,url}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{multirow}
\usepackage{float}
\title{Specifications for the Attitude Control and Determination System-XCubeSat} 
\author{Dhruv Sharma, Damien Seux, Quentin Lisack, Kevin Garanger}

\date{12 April 2015} 

\renewcommand{\titrecourt}{Specifications ADCS}
\setcounter{secnumdepth}{5}
\begin{document}
\maketitle

\tableofcontents
\listoffigures
\listoftables

\chapter{Introduction}

The objective of this document is to summarize in one place the specifications related to the software of the Attitude Control and Determination System, henceforth ADCS of the nano-satellite X-CubeSat developed by the students of Ã‰cole Polytechnique, Paris. We have divided the document into the following sections 

\begin{itemize}
\item 
Definition of the architecture of the ADCS 
\item 
External Interfaces available on the ADCS 
\item 
Sensors and peripherals on the ADCS 
\item 
Data formats used for computing 
\item 
Protocols for testing 
\end{itemize}

This document shall be useful for all people currently concerned with the conception of the ADCS and eventually for students who will take over the project in the months to come. This document is however, far from being complete and additions, corrections and deletions will be made till the day of delivery. 

\chapter{Architecture of the ADCS}\thispagestyle{fancy}

The ADCS uses a microprocessor manufactured by ST Microelectronics based on the ARM Cortex-M4 Architecture. The model used is STM 32F405 RGT6

The available interfaces, sensors and other peripherals available on the ADCS are: 

\begin{itemize}
\item 
32 MB External Memory  
\item 
7(or 9) sun sensors 
\item 
Magnetometer
\item 
Gyrometer
\item 
H-Bridges to modulate power to the magneto-torquers 
\item 
A Serial interface with the On-Board Computer (\textit{Ordinateur de Bord} henceforth, ODB) 
\end{itemize}

Following is the complete plan for the ADCS: 

\includepdf[pages={-},angle=90]{QB50_ADCS_ST.pdf}

\chapter{External interfaces} \thispagestyle{fancy}



\chapter{Software Architecture} \thispagestyle{fancy}
This is the heart of this document. We discuss here the architecture of the software, the various peripherals and the sensors mounted on the microprocessors, the various functions associated with them detailing every time the input, output and the configuration parameters for each of the peripherals. 

We first begin by detailing how the software has been divided. Next we define the various classes that we have divided the software into. While the first division is an abstract division that we made to facilitate the development of the software, the structure of classes and their interdependance correspond to how the software will actually be implemented. 

Once the abstract division and the structure of classes are defined we detail the correspondence of the various ports/ pins available on the microprocessor and the peripherals connected. Next, we define the functions corresponding to each of the divisions. Irrespective of their eventual use, all functions shall find themselves in one of three categories that we shall define in the section \textbf{Division of the software}. 


\section{Division of the software} 

\begin{figure}[!h]
\centering 
\includegraphics[width=10cm]{arch_layers.jpg}
\caption{\textit{Division of the software in three layers each independent of the other}}
\label{layers_arch_soft}
\end{figure}
 
The ADCS software is divided into the following layers 

\begin{enumerate}
\item 
\textbf{API Firmware}: In this layer, all the low-level functionalities are collected. By low-level functionalities, we mean all those functionalities which are not directly relevant to the functioning of the algorithms. This layer doesn't provide any data to the algorithms. Rather, this layer is concerned only with initializing and configuring the various peripherals that we have on the ADCS.
\item 
\textbf{Driver}: jhis layer acts as a bridge between the lower level API firmware and the higher-level specialized functions that we require to run our algorithms. Ideally, in this layer we find the functions which get the raw data from the sensors, convert or calibrate them as necessary and send them to the algorithms for further use.
\item 
\textbf{Specialized Functions}: The specialized functions are the functions which implement the algorithms for determining and controlling the attitude of the satellite. These functions are high-level functions and require the data provided to them by the \textit{Driver} layer above to function. 
\end{enumerate}

\section{Structure of classes} 
Once we have abstracted the software as being divided into layers depending on the kind of functions we will write for the software, we consider next the division of the software into dedicated classes. The class structure as envisaged for the ADCS is summarized in the graph below. The arrow head signifies that the a particular class gets a particular piece of data from the class where the arrow originates. 

\begin{figure}[h]
\centering 
\includegraphics[scale=0.6]{class_structure}
\caption{\textit{Class structure for ADCS Software}}
\label{struct_class}
\end{figure}

The various layers as shown in the class structure above are detailed below 

\begin{enumerate}
\item 
\textbf{Sensors}: This layer corresponds to the API Firmware layer that we presented earlier. We have three types of sensors: Gyrometer, a magnetometer and 9 sun-sensors. This part of the software corresponds to the initialization and configuring the sensors (and the ports to which they are associated on the microprocessor) so that they can start generating the data. 
\item 
\textbf{Calculations 1}: This layer consists of a first layer of calculations effectuated once raw data is received from the sensors. In this layer, we receive the raw data from the sun-sensors, magnetometer and the gyrometer. 

\item 
\textbf{Calculations 2}:This corresponds to a supplementary layer of calculations which is effectuated once the raw data has been received (not shown in the class structure). This step might take different forms for different sensors. For instance, once we have received the sun sensor raw data, the supplementary steps include converting the raw data into a voltage and further combining the data from the 9 sun-sensors into one sun-vector with three components. For the magnetometer however, we can eventually consider calibrating the data with the temperature. Identically for the gyrometer as well. 

Finally, this step also relates to reading the terrestrial magnetic field map and the albedo map from the external memory. All this data once collected, calibrated and treated will be given to the algorithms, which we explain below. 

\item 
\textbf{Attitude Determination and Control Phase}: Once the data has been generated (after eventual calibrations), we have the layer where the actual control of the satellite takes place. The details of the algorithms will be presented in an ulterior section. 

\item
\textbf{PD-like controller}: This is what controls the satellite by providing us as output the magnetic moment to be generated in the magnetic coils. The controller then gives its output to the Coils-Attitude Control Interface. 

\item 
\textbf{Interface Coils-Attitude Control}: This layer corresponds to the calculations to be done to configure the magneto-torquers. The magneto-torquers are controlled by Pulse-Width Modulation(PWM). For PWM, we require the frequency of modulation (in KHz) and the duty cycle (in percent). The result of the algorithms, however, is the magnetic moment to be generated by the magnetic torquers. Thus we require precise data on the behaviour of the magnetic coils used to convert this magnetic moment into a duty-cycle. (The frequency of modulation shall be fixed for all the coils)

\item 
\textbf{Magnetic Coils}: This is the layer which corresponds to the actual control that will be applied via the magnetic coils. The coils are powered via PWM for a fixed frequency usually aroun 15-20KHz. 
\end{enumerate}


\section{Definition of ports}

In this section we define the various ports, what their functionalities are and to which of the peripherals they are connected. 

We also specify the alternate functions that need to be configured for each of the ports. These alternate functions could be Serial Communication (USART) for communicating with the ODB or an Analog to Digital Converter (ADC) for the sun-sensors. 

\begin{table}[H]
%\centering
\resizebox{1.15\textwidth}{!}{%
\begin{tabular}{ccccccc}
\hline
\multicolumn{1}{|c|}{Peripheral} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Name of\\   the port\end{tabular}} & \multicolumn{1}{c|}{Port on MPU} & \multicolumn{1}{c|}{Logical State} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Alternate\\ Function(AF)\end{tabular}} & \multicolumn{1}{c|}{AF Details 1} & \multicolumn{1}{c|}{AF Details 2} \\ \hline
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \hline
\multicolumn{1}{|c|}{\multirow{5}{*}{\begin{tabular}[c]{@{}c@{}}Sun \\ Sensor\end{tabular}}} & \multicolumn{1}{c|}{GS5} & \multicolumn{1}{c|}{PC0} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{ADC} & \multicolumn{1}{c|}{ADC\_Resolution\_8b} & \multicolumn{1}{c|}{Channel10} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{GS4} & \multicolumn{1}{c|}{PC1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{ADC} & \multicolumn{1}{c|}{ADC\_Resolution\_8b} & \multicolumn{1}{c|}{Channel 11} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{GS3} & \multicolumn{1}{c|}{PC5} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{ADC} & \multicolumn{1}{c|}{ADC\_Resolution\_8b} & \multicolumn{1}{c|}{Channel 15} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{GS2} & \multicolumn{1}{c|}{PB0} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{ADC} & \multicolumn{1}{c|}{ADC\_Resolution\_8b} & \multicolumn{1}{c|}{Channel 8} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{GS1} & \multicolumn{1}{c|}{PB1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{ADC} & \multicolumn{1}{c|}{ADC\_Resolution\_8b} & \multicolumn{1}{c|}{Channel 9} \\ \hline
 &  &  &  &  &  &  \\ \hline
\multicolumn{1}{|c|}{\multirow{6}{*}{PWM}} & \multicolumn{1}{c|}{F1} & \multicolumn{1}{c|}{PB14} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{TIM1} & \multicolumn{1}{c|}{Output Compare} & \multicolumn{1}{c|}{} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{R1} & \multicolumn{1}{c|}{PB13} & \multicolumn{1}{c|}{0 or 1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{F2} & \multicolumn{1}{c|}{PB12} & \multicolumn{1}{c|}{0 or 1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{R2} & \multicolumn{1}{c|}{PB11} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{TIM2} & \multicolumn{1}{c|}{Output Compare} & \multicolumn{1}{c|}{} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{F3} & \multicolumn{1}{c|}{PB10} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{TIM2} & \multicolumn{1}{c|}{Output Compare} & \multicolumn{1}{c|}{} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{R3} & \multicolumn{1}{c|}{PA5} & \multicolumn{1}{c|}{0 or 1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \hline
 &  &  &  &  &  &  \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Comm\\ ODB\end{tabular}}} & \multicolumn{1}{c|}{TX\_ADCS} & \multicolumn{1}{c|}{PA10} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{USART1\_RX} & \multicolumn{1}{c|}{Baud Rate} & \multicolumn{1}{c|}{Bit size} \\ \cline{2-7} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{RX\_ADCS} & \multicolumn{1}{c|}{PA9} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{USART1\_TX} & \multicolumn{1}{c|}{Baud Rate} & \multicolumn{1}{c|}{Bit size} \\ \hline
 &  &  &  &  &  &  \\ \hline
\multicolumn{1}{|c|}{MISC} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}On/Off\\   Pont H\end{tabular}} & \multicolumn{1}{c|}{PB14} & \multicolumn{1}{c|}{0 or 1} & \multicolumn{1}{c|}{N/A} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \hline
\end{tabular}
}
\caption{List of peripherals with alternate functions and other configurable parameters}
\label{my-label}
\end{table}

\section{API Firmware} 

This section details all the functions concerning the initialization and configuration of the peripherals. 

\subsection{PWM} 
\subsection{ADC}
\subsection{USART} 

\section{Driver} 

\section{Specialized Functions} 

\chapter{Data formats}\thispagestyle{fancy}

\chapter{Testing}\thispagestyle{fancy} 


\end{document}